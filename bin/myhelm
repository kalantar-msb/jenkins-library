#!/bin/bash

#set -x

DIR=$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )

function upgrade_once_revision () {
  __name="${1}"

  icphelm upgrade --install ${HELM_OPTIONS} ${__name}-init ${ONCE_ONLY_CHART}
}

function create_version() {
  __revision_name="${1}"
  __init_cm="${2}"
  __reuse="false"
  if (( $# > 2 )); then
    __reuse="true"
  fi

  # Create the version
  # At the same time, record the new ${__revision_name} in ${__init_cm}.init (lookup via configmap ${NAME}.ver)
  # and create ${__revision_name}.ver to identify ${__init_cm} for future use

  # Create the version
  if [[ "true" == "${__reuse}" ]]; then
    icphelm upgrade --reuse-values ${__revision_name} ${VERSION_CHART}
  else
    icphelm upgrade --install ${HELM_OPTIONS} ${__revision_name} ${VERSION_CHART}
  fi

  # record ${__revision_name} in ${__init_cm}.init
  # example: '{"data": {"a": "{\"created\": \"2018-04-24T10:06:18+0000\", \"deleted\": \"2018-04-24T12:06:18+0000\"}"}}'
  # example: '{"data": {"b": "{\"created\": \"2018-04-24T13:06:18+0000\"}"}}'
  create_data="{\"data\": {\"${__revision_name}\": \"{\\\"created\\\": \\\"$(date --iso-8601='seconds')\\\"}\"}}"
  kubectl get cm ${__init_cm}.init
  if (( 0 != $? )); then
    kubectl create cm ${__init_cm}.init
  fi
  kubectl patch cm ${__init_cm}.init -p "$create_data"

  # record init revision in configmap ${__revision_name}.ver
  create_ver_cm ${__revision_name} ${__init_cm}
}

function create_init_cm() {
  __init_cm="${1}"

  kubectl create cm ${INIT_NM}.init
}

function create_ver_cm() {
  __revision_name="${1}"
  __init_cm="${2}"

  kubectl create cm ${__revision_name}.ver --from-literal=parent=${__init_cm}
}

function delete_version() {
  __revision_name="${1}"
  __init_cm="${2}"

  delete_data="{\"data\": {\"${__revision_name}\": \"$(kubectl get cm ${__init_cm}.init -o json | jq --raw-output ".data[\"$__revision_name\"]" | jq --arg now $(date --iso-8601='seconds') '. + {deleted: $now}' | sed 's/"/\\"/g' | tr '\r\n' ' ' | sed 's/[[:space:]]//g')\"}}"
  #echo $delete_data

  kubectl patch cm ${__init_cm}.init -p "$delete_data"
  kubectl delete cm ${__revision_name}.ver
  icphelm ${ACTION} ${HELM_OPTIONS} ${__revision_name} && rc=$? || rc=$?
  return $rc
}

ACTION="${1}"; shift

if [[ "${ACTION}" == "upgrade" ]]; then
  INSTALL=
  HELM_OPTIONS=''
  VERSION=
  while (( $# )); do
    case "${1}" in

      --install|-i)
                INSTALL="${1}"
                shift
                ;;

      # flags without additional parameters
      --devel|--dry-run|--no-hooks|--recreate-pods|--reset-values|--reuse-values|--tls|--tls-verify|--verify|--wait|--debug)
                HELM_OPTIONS="${HELM_OPTIONS} ${1}"
                shift
                ;;

      # flags with additional parameter
      --ca-file|--cert-file|--key-file|--keyring|--namespace|--repo|--set|--timeout|--tls-ca-cert|--tls-cert|--tls-key|--values|--version|--home|--host|--kube-context|--kubeconfig|--tiller-namespace)
                HELM_OPTIONS="${HELM_OPTIONS} ${1} ${2}"
                shift; shift
                ;;

      --new-version)
                VERSION="${2}"
                shift; shift
                ;;

      *) 
                if [[ -z "${NAME}" ]]; then NAME="${1}"; else SOURCE_CHART="${1}"; fi
                shift
                ;;

    esac
  done

  # if no --new-version flag, just call upgrade
  if [[ -z "${VERSION}" ]]; then
    icphelm ${ACTION} ${INSTALL} ${HELM_OPTIONS} ${NAME} ${SOURCE_CHART} && rc=$? || rc=$?
    exit ${rc}
  fi

  # Split chart into -init and -ver charts
  WORK_DIR=/tmp/tmp$$
  mkdir -p ${WORK_DIR}

  CHART_DIR=$(dirname ${SOURCE_CHART})
  ONCE_ONLY_CHART="${WORK_DIR}/${SOURCE_CHART}-init"
  VERSION_CHART="${WORK_DIR}/${SOURCE_CHART}-version"

  cp -r ${SOURCE_CHART} ${ONCE_ONLY_CHART}
  for f in ${ONCE_ONLY_CHART}/templates/*; do
    grep --silent 'chart-use:[[:space:]]*once' ${f} && rc=$? || rc=$?
    if (( ${rc} )); then rm ${f}; fi
  done
  sed -i 's/\(version:.*\)/\1-init/' ${ONCE_ONLY_CHART}/Chart.yaml

  cp -r ${SOURCE_CHART} ${VERSION_CHART}
  for f in ${VERSION_CHART}/templates/*; do
    grep --silent 'chart-use:[[:space:]]*once' ${f} && rc=$? || rc=$?
    if (( ${rc} == 0 )); then rm ${f}; fi
  done
  sed -i 's/\(version:.*\)/\1-ver/' ${VERSION_CHART}/Chart.yaml

  # deploy charts

  icphelm list ${NAME} | grep "^${NAME}"
  if (( 1 == $? )); then
    # ${NAME} does not exist. Either it has never been deployed OR it was deployed and has since been deleted.
    # In either case, we should feel free to try again to deploy something with that ${NAME}
    # Create a ${NAME}-init revision containing just the 'once' objects take them out, and
    # Create a ${NAME}.init configmap to keep track of the versions that are created, and
    # Create a ${VERSION} revision containing the currently deployed version
    # Create a ${VERSION}.ver configmap to point back at the init objects
    INIT_NM="${NAME}"
    upgrade_once_revision ${NAME}
    create_init_cm ${INIT_NM}
    create_version ${VERSION} ${INIT_NM}
    # We are deploying $VERSION only, not $NAME (previous line), but record parent in ${NAME}.ver
    # Should it be added to ${INIT_NM}.init as well?
    if [[ "${NAME}" != "${VERSION}" ]]; then
      create_ver_cm ${NAME} ${__init_cm}
    fi
  else
    # ${NAME} exists. Either it was deployed without versions OR it was.
    kubectl get cm ${NAME}.ver
    if (( $? )); then
      # ${NAME} was NOT deployed as a version. Need to:
      # Create a ${NAME}-init revision containing just the 'once' objects take them out, and
      # Create a ${NAME} revision containing the currently deployed version
      # Create a ${NAME}.init configmap to keep track of the versions that are created, and
      # Create a ${NAME}.ver configmap to point back at the init objects
      # Create a ${VERSION} revision containing ${VERSION} deployed version (if $NAME != $VERSION)
      # Create a ${VERSION}.ver configmap to point back at the init objects
      INIT_NM="${NAME}"
      upgrade_once_revision ${NAME}
      create_init_cm ${INIT_NM}
      create_version ${NAME} ${INIT_NM} "true"
      create_version ${VERSION} ${INIT_NM}
    else
      # ${NAME} revision was deployed as a version.
      # Create a ${VERSION} revision containing ${VERSION} deployed version (if $NAME != $VERSION)
      # Create a ${VERSION}.ver configmap to point back at the init objects
      # Update ${INIT_NM}.ver configmap to keep trace of ${VERSION}
      INIT_NM=$(kubectl get cm ${NAME}.ver -o json | jq --raw-output '.data.parent')
      upgrade_once_revision ${NAME}
      create_version ${VERSION} ${INIT_NM}
    fi
  fi

  # Cleanup the working directory
  rm -rf ${WORK_DIR}

elif [[ "${ACTION}" == "delete" ]]; then
  HELM_OPTIONS=''
  VERSIONS=
  while (( $# )); do
    case "${1}" in

      # flags without additional parameters
      --dry-run|--no-hooks|--purge|--tls|--tls-verify|--debug)
                HELM_OPTIONS="${HELM_OPTIONS} ${1}"
                shift
                ;;

      # flags with additional parameter
      --timeout|--tls-ca-cert|--tls-cert|--tls-key|--home|--host|--kube-context|--kubeconfig|--tiller-namespace)
                HELM_OPTIONS="${HELM_OPTIONS} ${1} ${2}"
                shift; shift
                ;;

      --all-versions)
                VERSIONS=true
                shift
                ;;

      *) 
                NAME="${1}"
                shift
                ;;
    esac
  done

  kubectl get cm ${NAME}.ver
  if (( 0 != $? )); then
    # $NAME was not the result of a version based upgrade; just delete it
    icphelm ${ACTION} ${HELM_OPTIONS} ${NAME} && rc=$? || rc=$?
    exit $rc
  fi

  INIT_NM=$(kubectl get cm ${NAME}.ver -o json | jq --raw-output '.data.parent')

  if [[ -n "${VERSIONS}" ]]; then
    for N in $(kubectl get cm ${INIT_NM}.init -o json  | jq --raw-output '.data' | grep -v deleted | grep -v "[{}]$" | awk '{print $1}' | sed 's/[":]//g'); do 
      delete_version ${N} ${INIT_NM}
    done
    icphelm delete ${INIT_NM}-init --purge
    kubectl delete cm ${INIT_NM}.init
    kubectl delete cm ${NAME}.ver || true
    exit 0
  fi

  delete_version ${NAME} ${INIT_NM} && rc=$? || rc=$?
  exit $rc

else
  icphelm ${ACTION} $@

fi # if [[ "${ACTION}" == ".." ]]; then
